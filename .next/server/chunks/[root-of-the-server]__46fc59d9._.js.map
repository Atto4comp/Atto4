{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 6, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 66, "column": 0}, "map": {"version":3,"sources":["file:///home/flex/Atto4/app/api/proxy/route.ts"],"sourcesContent":["// app/api/proxy/route.ts\nimport { NextRequest, NextResponse } from \"next/server\";\n\n/**\n * Conservative proxy for embed pages.\n * - Accepts ?target=<absolute-url>\n * - Validates host against a whitelist to avoid becoming an open proxy\n * - Fetches the target with timeout + retry/backoff\n * - For HTML responses, rewrites allowed absolute resource URLs to route through this proxy\n * - Returns the fetched response body and content-type (with some security headers removed so iframes can work)\n *\n * NOTE: Keep ALLOWED_HOSTS to plain hostnames (no templates, no querystrings).\n */\n\nconst ALLOWED_HOSTS = [\n  \"vidlink.pro\",\n  \"vidsrc.to\",\n  \"vidsrc.stream\",\n  \"2embed.cc\",\n  \"embedsb.com\",\n  \"doodstream.com\",\n  \"streamtape.com\",\n  \"111movies.com\",\n  \"player.111movies.com\",\n  \"embed.111movies.com\",\n];\n\nfunction getHostname(u: string | null) {\n  try {\n    if (!u) return null;\n    const hostname = new URL(u).hostname;\n    return hostname.replace(/^www\\./, \"\").toLowerCase();\n  } catch {\n    return null;\n  }\n}\n\nfunction hostAllowed(host: string | null) {\n  if (!host) return false;\n  return ALLOWED_HOSTS.some(h => host === h || host.endsWith(`.${h}`));\n}\n\n/** Basic sleep for backoff */\nconst sleep = (ms: number) => new Promise((r) => setTimeout(r, ms));\n\n/**\n * Fetch with timeout + retry/backoff.\n * Returns the fetch Response on success or throws a detailed Error on permanent failure.\n */\nasync function fetchWithTimeoutAndRetry(url: string, timeoutMs = 10000, retries = 2) {\n  const parsed = new URL(url);\n  const origin = parsed.origin;\n\n  // Defensive headers — some hosts block empty UA or require referer/origin\n  const baseHeaders: Record<string, string> = {\n    \"User-Agent\": \"Mozilla/5.0 (compatible; Atto4Proxy/1.0)\",\n    Accept: \"*/*\",\n    // set referer to origin which often helps bypass naive origin checks\n    Referer: origin,\n    Origin: origin,\n  };\n\n  for (let attempt = 0; attempt <= retries; attempt++) {\n    const controller = new AbortController();\n    const id = setTimeout(() => controller.abort(), timeoutMs);\n\n    try {\n      const resp = await fetch(url, {\n        method: \"GET\",\n        signal: controller.signal,\n        headers: baseHeaders,\n        // do not forward credentials\n        credentials: \"omit\",\n      });\n      clearTimeout(id);\n      return resp;\n    } catch (err: any) {\n      clearTimeout(id);\n\n      const msg = err?.message || String(err);\n      const code = err?.code || \"\";\n\n      // Consider these transient and retryable\n      const transient = /ECONNRESET|ETIMEDOUT|EAI_AGAIN|ENOTFOUND|network|timeout|aborted|Failed to fetch/i.test(msg) || code === \"ECONNRESET\" || code === \"ETIMEDOUT\";\n\n      if (attempt === retries || !transient) {\n        // final failure: throw with cause\n        const e = new Error(`fetch failed (attempt ${attempt + 1}): ${msg}`);\n        (e as any).cause = err;\n        throw e;\n      }\n\n      const backoff = 300 * (2 ** attempt); // 300ms, 600ms, 1200ms...\n      console.warn(`Transient fetch error for ${url} (attempt ${attempt + 1}/${retries}). Retrying ${backoff}ms.`, msg);\n      await sleep(backoff);\n      // loop to retry\n    }\n  }\n\n  // unreachable\n  throw new Error(\"unreachable fetchWithTimeoutAndRetry\");\n}\n\n/**\n * Rewrite absolute src/href occurrences to route through this proxy for allowed hosts only.\n * Conservative implementation — rewrites attributes like src=\"https://host/...\" and href=\"...\"\n */\nfunction rewriteAbsoluteUrlsToProxy(htmlText: string) {\n  // Replace src=\"https://host/...\" and href=\"https://host/...\" occurrences\n  const replaced = htmlText.replace(/(src|href)=(\"https?:\\/\\/[^\"]+\"|'https?:\\/\\/[^']+')/gi, (m, attr, quotedUrl) => {\n    const url = quotedUrl.slice(1, -1);\n    const host = getHostname(url);\n    if (!host) return `${attr}=${quotedUrl}`;\n    if (hostAllowed(host)) {\n      return `${attr}=\"/api/proxy?target=${encodeURIComponent(url)}\"`;\n    }\n    return `${attr}=${quotedUrl}`;\n  });\n\n  // Also rewrite simple JS string occurrences like \"https://host/...\" or 'https://host/...'\n  const finalText = replaced.replace(/(['\"`])(https?:\\/\\/[^'\"` ]+)['\"`]/gi, (m, quote, candidate) => {\n    try {\n      const host = getHostname(candidate);\n      if (host && hostAllowed(host)) {\n        return `${quote}/api/proxy?target=${encodeURIComponent(candidate)}${quote}`;\n      }\n    } catch { /* ignore */ }\n    return m;\n  });\n\n  return finalText;\n}\n\nexport async function GET(request: NextRequest) {\n  try {\n    const target = request.nextUrl.searchParams.get(\"target\");\n    if (!target) {\n      return NextResponse.json({ success: false, error: \"Missing target query param\" }, { status: 400 });\n    }\n\n    const hostname = getHostname(target);\n    if (!hostname) {\n      return NextResponse.json({ success: false, error: \"Invalid target URL\" }, { status: 400 });\n    }\n\n    if (!hostAllowed(hostname)) {\n      return NextResponse.json({ success: false, error: \"Host not allowed\", host: hostname }, { status: 403 });\n    }\n\n    // Fetch remote with retries/timeouts\n    let resp;\n    try {\n      resp = await fetchWithTimeoutAndRetry(target, 10000, 2);\n    } catch (err: any) {\n      console.error(\"Proxy fetch failed:\", err?.message || err);\n      // Surface the error message for easier debugging client-side\n      return NextResponse.json({ success: false, error: \"Failed to fetch target\", details: err?.message || String(err) }, { status: 502 });\n    }\n\n    if (!resp) {\n      return NextResponse.json({ success: false, error: \"No response from target\" }, { status: 502 });\n    }\n\n    const contentType = resp.headers.get(\"content-type\") || \"\";\n\n    // If non-2xx, return a diagnostic JSON (helps check-embed figure out what's returned)\n    if (!resp.ok) {\n      // try to read a snippet of the body\n      let snippet = \"\";\n      try {\n        const txt = await resp.text();\n        snippet = typeof txt === \"string\" ? txt.slice(0, 2000) : \"\";\n      } catch (e) {\n        snippet = \"(failed to read body)\";\n      }\n      return NextResponse.json({\n        success: false,\n        status: resp.status,\n        statusText: resp.statusText,\n        message: `Upstream returned ${resp.status} ${resp.statusText}`,\n        bodySnippet: snippet\n      }, { status: 502 });\n    }\n\n    // HTML -> rewrite allowed absolute links and return rewritten HTML\n    if (contentType.includes(\"text/html\")) {\n      const text = await resp.text();\n      const rewritten = rewriteAbsoluteUrlsToProxy(text);\n\n      return new NextResponse(rewritten, {\n        status: resp.status,\n        headers: {\n          \"content-type\": \"text/html; charset=utf-8\",\n          // be careful adding CORS here; we want this HTML embeddable by same-origin iframes\n          \"x-proxy-by\": \"Atto4-Proxy\",\n          // remove anti-embedding headers by not forwarding them\n        },\n      });\n    }\n\n    // For binary or other content types, forward the bytes and most headers (but strip framing/security headers)\n    const arrayBuffer = await resp.arrayBuffer();\n    const forwardedHeaders: Record<string, string> = {};\n\n    resp.headers.forEach((v, k) => {\n      const low = k.toLowerCase();\n      // strip headers that would prevent embedding or are hop-by-hop\n      if ([\"content-security-policy\", \"x-frame-options\", \"set-cookie\", \"transfer-encoding\", \"connection\"].includes(low)) return;\n      forwardedHeaders[k] = v;\n    });\n\n    // Ensure content-type is set\n    if (!forwardedHeaders[\"content-type\"]) forwardedHeaders[\"content-type\"] = contentType || \"application/octet-stream\";\n    // Mark proxy\n    forwardedHeaders[\"x-proxy-by\"] = \"Atto4-Proxy\";\n\n    // NextResponse expects a BodyInit; Buffer.from works in Node runtime\n    return new NextResponse(Buffer.from(arrayBuffer), {\n      status: resp.status,\n      headers: forwardedHeaders,\n    });\n\n  } catch (err) {\n    console.error(\"Proxy error:\", err);\n    const message = err instanceof Error ? err.message : String(err);\n    return NextResponse.json({ success: false, error: \"Internal proxy error\", details: message }, { status: 500 });\n  }\n}\n"],"names":[],"mappings":"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","debugId":null}}]
}