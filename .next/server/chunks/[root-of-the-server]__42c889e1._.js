module.exports = {

"[project]/.next-internal/server/app/api/check-embed/route/actions.js [app-rsc] (server actions loader, ecmascript)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
}}),
"[externals]/next/dist/compiled/next-server/app-route-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-route-turbo.runtime.dev.js, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js"));

module.exports = mod;
}}),
"[externals]/next/dist/compiled/@opentelemetry/api [external] (next/dist/compiled/@opentelemetry/api, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/compiled/@opentelemetry/api", () => require("next/dist/compiled/@opentelemetry/api"));

module.exports = mod;
}}),
"[externals]/next/dist/compiled/next-server/app-page-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-page-turbo.runtime.dev.js, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js"));

module.exports = mod;
}}),
"[externals]/next/dist/server/app-render/work-unit-async-storage.external.js [external] (next/dist/server/app-render/work-unit-async-storage.external.js, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/server/app-render/work-unit-async-storage.external.js", () => require("next/dist/server/app-render/work-unit-async-storage.external.js"));

module.exports = mod;
}}),
"[externals]/next/dist/server/app-render/work-async-storage.external.js [external] (next/dist/server/app-render/work-async-storage.external.js, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/server/app-render/work-async-storage.external.js", () => require("next/dist/server/app-render/work-async-storage.external.js"));

module.exports = mod;
}}),
"[externals]/next/dist/shared/lib/no-fallback-error.external.js [external] (next/dist/shared/lib/no-fallback-error.external.js, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/shared/lib/no-fallback-error.external.js", () => require("next/dist/shared/lib/no-fallback-error.external.js"));

module.exports = mod;
}}),
"[externals]/next/dist/server/app-render/after-task-async-storage.external.js [external] (next/dist/server/app-render/after-task-async-storage.external.js, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/server/app-render/after-task-async-storage.external.js", () => require("next/dist/server/app-render/after-task-async-storage.external.js"));

module.exports = mod;
}}),
"[externals]/util [external] (util, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("util", () => require("util"));

module.exports = mod;
}}),
"[externals]/stream [external] (stream, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("stream", () => require("stream"));

module.exports = mod;
}}),
"[externals]/path [external] (path, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("path", () => require("path"));

module.exports = mod;
}}),
"[externals]/http [external] (http, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("http", () => require("http"));

module.exports = mod;
}}),
"[externals]/https [external] (https, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("https", () => require("https"));

module.exports = mod;
}}),
"[externals]/url [external] (url, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("url", () => require("url"));

module.exports = mod;
}}),
"[externals]/fs [external] (fs, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("fs", () => require("fs"));

module.exports = mod;
}}),
"[externals]/crypto [external] (crypto, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("crypto", () => require("crypto"));

module.exports = mod;
}}),
"[externals]/assert [external] (assert, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("assert", () => require("assert"));

module.exports = mod;
}}),
"[externals]/tty [external] (tty, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("tty", () => require("tty"));

module.exports = mod;
}}),
"[externals]/os [external] (os, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("os", () => require("os"));

module.exports = mod;
}}),
"[externals]/zlib [external] (zlib, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("zlib", () => require("zlib"));

module.exports = mod;
}}),
"[externals]/events [external] (events, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("events", () => require("events"));

module.exports = mod;
}}),
"[project]/lib/api/video-api.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

// lib/api/video-api.ts
__turbopack_context__.s({
    "buildEmbedUrl": ()=>buildEmbedUrl,
    "getEmbedUrlCandidates": ()=>getEmbedUrlCandidates,
    "resolveTmdbId": ()=>resolveTmdbId,
    "videoApi": ()=>videoApi
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$axios$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/axios/lib/axios.js [app-route] (ecmascript)");
;
/** Read and normalize environment variables */ const ENV = {
    BASE: (("TURBOPACK compile-time value", "https://vidsrc.to/embed/movie/") || "").trim(),
    E1: (process.env.NEXT_PUBLIC_VIDEO_EMBED_1 || "https://vidlink.pro/tv/${id}/${season}/${episode}?startAt=60&primaryColor=3a86ff&autoplay=true&nextbutton=true&sub_file=https://example.com/subtitles.vtt&sub_label=English").trim(),
    E2: (process.env.NEXT_PUBLIC_VIDEO_EMBED_2 || "https://vidlink.pro/movie/${id}?startAt=60&primaryColor=3a86ff&autoplay=true&nextbutton=true&sub_file=https://example.com/subtitles.vtt&sub_label=English").trim(),
    E3: (process.env.NEXT_PUBLIC_VIDEO_EMBED_3 || "").trim(),
    E4: (process.env.NEXT_PUBLIC_VIDEO_EMBED_4 || "").trim()
};
/** Global extra params appended to every embed URL */ const EXTRA_PARAMS = (process.env.NEXT_PUBLIC_VIDEO_URL_PARAMS || "").trim();
/** Providers list with friendly names (fallback order) */ const VIDEO_PROVIDERS = [
    {
        name: "Primary",
        value: ENV.E1,
        priority: 1
    },
    {
        name: "Secondary",
        value: ENV.E2,
        priority: 2
    },
    {
        name: "Tertiary",
        value: ENV.E3,
        priority: 3
    },
    {
        name: "Backup",
        value: ENV.E4,
        priority: 4
    },
    {
        name: "Base",
        value: ENV.BASE,
        priority: 5
    }
].filter((p)=>!!p.value);
/** Extract hostname for friendly server label */ function getServerLabel(url) {
    try {
        const hostname = new URL(url).hostname;
        return hostname.replace(/^www\./, '');
    } catch  {
        return 'Unknown Server';
    }
}
/** Build the default embed path for base URLs */ function buildEmbedPath(mediaType, tmdbId, season, episode) {
    if (mediaType === "movie") return `/movie/${tmdbId}`;
    if (season && episode) return `/tv/${tmdbId}/${season}/${episode}`;
    return `/tv/${tmdbId}`;
}
/** Check if provider uses template placeholders */ function isTemplate(url) {
    return /\$\{(id|type|season|episode)\}/.test(url);
}
/** Normalize base URL (remove trailing slash) */ function normalizeBase(url) {
    return url.endsWith("/") ? url.slice(0, -1) : url;
}
/** Append query parameters safely */ function appendParams(url, params) {
    if (!params) return url;
    return url + (url.includes("?") ? "&" : "?") + params;
}
/** Build raw URL from template or base provider */ function buildRawUrl(providerValue, mediaType, tmdbId, season, episode) {
    if (isTemplate(providerValue)) {
        // Template mode: replace placeholders
        return providerValue.replace(/\$\{id\}/g, String(tmdbId)).replace(/\$\{type\}/g, mediaType).replace(/\$\{season\}/g, season ? String(season) : "1").replace(/\$\{episode\}/g, episode ? String(episode) : "1");
    }
    // Base mode: append canonical path
    const base = normalizeBase(providerValue);
    return `${base}${buildEmbedPath(mediaType, tmdbId, season, episode)}`;
}
function buildEmbedUrl(providerValue, mediaType, tmdbId, season, episode) {
    const raw = buildRawUrl(providerValue, mediaType, tmdbId, season, episode);
    return appendParams(raw, EXTRA_PARAMS);
}
function getEmbedUrlCandidates(mediaType, tmdbId, season, episode) {
    const urls = VIDEO_PROVIDERS.map((provider)=>buildEmbedUrl(provider.value, mediaType, tmdbId, season, episode));
    // Remove duplicates while preserving order
    return [
        ...new Set(urls)
    ];
}
/** Create VideoSource from provider */ function createVideoSource(provider, mediaType, tmdbId, season, episode) {
    const url = buildEmbedUrl(provider.value, mediaType, tmdbId, season, episode);
    return {
        url,
        quality: "HD",
        type: "iframe",
        servers: `${provider.name} (${getServerLabel(url)})`,
        tmdbId,
        mediaType
    };
}
async function resolveTmdbId(input, type) {
    if (typeof input === "number" && Number.isFinite(input)) return input;
    const str = String(input).trim();
    const asNum = Number(str);
    if (Number.isFinite(asNum)) return asNum;
    // Handle IMDb IDs
    if (/^tt\d+$/i.test(str)) {
        const API_KEY = ("TURBOPACK compile-time value", "21cd0c00d578f346fd8a0ffefb679e24")?.trim();
        if (!API_KEY) return null;
        try {
            const { data } = await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$axios$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].get(`https://api.themoviedb.org/3/find/${str}`, {
                params: {
                    api_key: API_KEY,
                    external_source: "imdb_id"
                },
                timeout: 5000
            });
            const results = type === "movie" ? data.movie_results : data.tv_results;
            return results?.[0]?.id ?? null;
        } catch (error) {
            console.error('Failed to resolve IMDb ID:', error);
            return null;
        }
    }
    return null;
}
const videoApi = {
    /** Check if any video APIs are configured */ hasConfiguredApis () {
        return VIDEO_PROVIDERS.length > 0;
    },
    /** Get configuration status for debugging */ getConfigStatus () {
        return {
            configured: VIDEO_PROVIDERS.length,
            providers: VIDEO_PROVIDERS.map((p)=>({
                    name: p.name,
                    configured: !!p.value,
                    isTemplate: isTemplate(p.value),
                    priority: p.priority
                })),
            extraParams: EXTRA_PARAMS || 'none'
        };
    },
    /** Get all embed URL candidates for media */ getEmbedUrlCandidates,
    /** Get movie video sources */ async getMovieSources (tmdbId) {
        return VIDEO_PROVIDERS.map((provider)=>createVideoSource(provider, "movie", tmdbId));
    },
    /** Get TV show video sources */ async getTVSources (tmdbId, season, episode) {
        return VIDEO_PROVIDERS.map((provider)=>createVideoSource(provider, "tv", tmdbId, season, episode));
    },
    /** Get movie with embed data */ async getMovieWithEmbed (tmdbId) {
        const API_KEY = ("TURBOPACK compile-time value", "21cd0c00d578f346fd8a0ffefb679e24")?.trim();
        try {
            const [movieResponse, sources] = await Promise.all([
                API_KEY ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$axios$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].get(`https://api.themoviedb.org/3/movie/${tmdbId}`, {
                    params: {
                        api_key: API_KEY
                    },
                    timeout: 10000
                }) : Promise.resolve({
                    data: null
                }),
                this.getMovieSources(tmdbId)
            ]);
            return {
                movie: movieResponse.data,
                embedUrl: sources[0]?.url || "",
                sources
            };
        } catch (error) {
            console.error('Error fetching movie with embed:', error);
            return {
                movie: null,
                embedUrl: "",
                sources: []
            };
        }
    },
    /** Get TV show with embed data */ async getTVShowWithEmbed (tmdbId, season, episode) {
        const API_KEY = ("TURBOPACK compile-time value", "21cd0c00d578f346fd8a0ffefb679e24")?.trim();
        try {
            const [tvResponse, sources] = await Promise.all([
                API_KEY ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$axios$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].get(`https://api.themoviedb.org/3/tv/${tmdbId}`, {
                    params: {
                        api_key: API_KEY
                    },
                    timeout: 10000
                }) : Promise.resolve({
                    data: null
                }),
                this.getTVSources(tmdbId, season, episode)
            ]);
            return {
                tvShow: tvResponse.data,
                embedUrl: sources[0]?.url || "",
                sources
            };
        } catch (error) {
            console.error('Error fetching TV show with embed:', error);
            return {
                tvShow: null,
                embedUrl: "",
                sources: []
            };
        }
    },
    /** Debug helper to log all configured providers */ logConfiguration () {
        console.log('Video API Configuration:', this.getConfigStatus());
    }
};
}),
"[project]/app/api/check-embed/route.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

// app/api/check-embed/route.ts
__turbopack_context__.s({
    "GET": ()=>GET,
    "POST": ()=>POST
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/server.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$api$2f$video$2d$api$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/lib/api/video-api.ts [app-route] (ecmascript)");
;
;
async function checkUrl(url, timeoutMs = 5000) {
    try {
        const controller = new AbortController();
        const timeoutId = setTimeout(()=>controller.abort(), timeoutMs);
        const response = await fetch(url, {
            method: 'HEAD',
            signal: controller.signal,
            headers: {
                'User-Agent': 'Mozilla/5.0 (compatible; EmbedChecker/1.0)'
            }
        });
        clearTimeout(timeoutId);
        return response.ok;
    } catch (error) {
        return false;
    }
}
async function POST(request) {
    try {
        const body = await request.json();
        const { mediaType, tmdbId, season, episode } = body;
        if (!mediaType || !tmdbId) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                error: 'Missing required parameters'
            }, {
                status: 400
            });
        }
        // Get all embed URL candidates
        const urls = __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$api$2f$video$2d$api$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["videoApi"].getEmbedUrlCandidates(mediaType, tmdbId, season, episode);
        if (urls.length === 0) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                error: 'No embed URLs configured'
            }, {
                status: 404
            });
        }
        // Test each URL in order
        const results = [];
        let workingUrl = null;
        for(let i = 0; i < urls.length; i++){
            const url = urls[i];
            const isWorking = await checkUrl(url, 5000);
            results.push({
                url,
                index: i,
                working: isWorking,
                tested: true
            });
            if (isWorking && !workingUrl) {
                workingUrl = url;
            }
            // Log for debugging
            console.log(`Check ${i + 1}/${urls.length}: ${isWorking ? '✓' : '✗'} ${url}`);
        }
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            success: true,
            workingUrl,
            totalTested: urls.length,
            results,
            mediaType,
            tmdbId,
            season,
            episode
        });
    } catch (error) {
        console.error('Embed check API error:', error);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            error: 'Internal server error'
        }, {
            status: 500
        });
    }
}
async function GET(request) {
    const { searchParams } = new URL(request.url);
    const mediaType = searchParams.get('mediaType');
    const tmdbId = searchParams.get('tmdbId');
    const season = searchParams.get('season');
    const episode = searchParams.get('episode');
    if (!mediaType || !tmdbId) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            error: 'Missing mediaType or tmdbId parameters'
        }, {
            status: 400
        });
    }
    const urls = __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$api$2f$video$2d$api$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["videoApi"].getEmbedUrlCandidates(mediaType, parseInt(tmdbId), season ? parseInt(season) : undefined, episode ? parseInt(episode) : undefined);
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
        mediaType,
        tmdbId: parseInt(tmdbId),
        season: season ? parseInt(season) : undefined,
        episode: episode ? parseInt(episode) : undefined,
        urls,
        configured: __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$api$2f$video$2d$api$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["videoApi"].hasConfiguredApis(),
        status: __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$api$2f$video$2d$api$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["videoApi"].getConfigStatus()
    });
}
}),

};

//# sourceMappingURL=%5Broot-of-the-server%5D__42c889e1._.js.map